AOP:面向切面编程（底层就是动态代理），动态代理的规范化，把动态代理的实现步骤、方式都定义好了，让开发人员用一种统一的方式来使用动态代理

实现方式:
1、jdk动态代理，使用jdk中的Proxy、Method、InvocationHandler创建代理对象，但是jdk动态代理要求目标类必须实现接口。
2、cglib动态代理：第三方的工具库来创建代理对象，原理是继承，通过继承目标类，创建子类，子类就是代理对象，但是要求目标类不能是final的，
   方法也不能是final的

动态代理的作用：
1、在目标类源代码不改变的情况下，增加某些功能
2、减少代码的重复
3、专注业务逻辑代码
4、解耦合，让业务功能和日志、事务等非业务功能分离

=================================================================================================================================

AOP的A：aspect，给目标类增加的功能就是切面，比如日志、事务就是切面，切面的特点一般都是非业务方法，可以独立使用的

因此在面向切面编程过程中，应该这样探究：
1、需要在分析项目功能时，找出切面
2、合理安排切面的执行时间（在目标方法前，还是在目标方法后执行）
3、合理安排切面的执行位置（在哪个类。哪个方法中增加切面）

=================================================================================================================================

AOP中的术语：
1、Aspect：切面，表示增强的功能，就是一堆代码，完成某个非业务功能，常见的切面有日志、事务、统计信息、参数检查、权限验证
2、Joinpoint：连接点，连接业务方法和切面的位置。------>一个方法
3、Pointcut：切入点，指多个连接点方法的集和。-------->多个方法
4、目标对象：给哪个类的方法增加功能，这个类就是目标对象
5、Advice：表示切面功能执行的时间

切面的三个关键要素：（与上面的探究对应）
1、切面的功能代码，就是切面能干什么---------------------->Aspect
2、切面的执行位置，就是哪个类、哪个方法需要切面------------>Pointcut
3、切面的执行时间，就是切面在目标方法之前还是之后执行------->Advice

=================================================================================================================================

AOP的技术实现框架：
1、spring：spring在内部实现了AOP规范，能做AOP的工作，主要在事务处理时使用AOP，但是项目中很少使用此方式，因为比较笨重
2、aspectJ：一个开源的专门做AOP的框架，spring中集成了aspectJ框架，因此通过spring就能使用aspectJ的功能。

aspectJ框架实现AOP有两种方式：
1、使用xml配置文件（在配置全局事务的时候）
2、使用注解，一般都使用注解的形式

=================================================================================================================================

aspectJ框架的使用：
1、切面的执行时间：切面是在目标方法之前还是之后执行--------->Advice
   在aspectJ框架中使用注解表示的。也可以使用xml文件中的标签
   @Before
   @AfterReturning
   @Around
   @AfterThrowing
   @After
2、切面的执行位置：在哪个类、哪个方法中需要切面------------>Pointcut
   在aspectJ框架中使用的是切入点表达式：execution(访问权限，方法返回值，方法声明(参数) 异常类型)
   execution(modifiers-pattern? ret-type-pattern
             declaring-type-pattern?name-pattern(param-pattern)
             throws-pattern?)

   modifiers-pattern:方法的访问权限类型
   ret-type-pattern：方法的返回值类型
   declaring-type-pattern:方法所在的包名类名
   name-pattern(param-pattern)：方法名(参数类型和参数个数)
   throws-pattern：方法抛出的异常类型
   ?：可省略
   以上的-pattern部分是可以使用通配符的
   *      0至多个任意字符
   ..     用在方法参数中，表示任意多个参数，用在包名后，表示当前包及其子包路径

=================================================================================================================================































